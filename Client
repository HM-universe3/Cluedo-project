import pygame
from pygame.locals import Rect
import random
import socket
from _thread import *
import threading
import sys
import pickle

pygame.init()


width = 600
height = 600
WIN = pygame.display.set_mode((width, height))
pygame.display.set_caption("Client")
listOfColours = [(0, 255, 0), ()]
clientNumber = 0

class Player():
  def __init__(self, x, y, width, height, colour, name):
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self.colour = colour
    self.rect = (self.x,self.y,self.width,self.height)
    self.velocity = 0.5
    self.name = name
    self.inventory = []
  def draw(self, WIN):
    pygame.draw.rect(WIN, self.colour, self.rect)

  def sendPosition(self, client_socket):
    positionData = pickle.dumps((self.x, self.y)) #player's position data
    client_socket.send(positionData)

  def receivePositions(self, client_socket):
    serverData = client_socket.recv(1024)
    positions = pickle.loads(serverData)
    return positions
  def move(self):
    keys = pygame.key.get_pressed()
    if keys[pygame.K_LEFT] or keys[pygame.K_a]:
      self.x -= self.velocity

    if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
      self.x += self.velocity

    if keys[pygame.K_UP] or keys[pygame.K_w]:
      self.y -= self.velocity

    if keys[pygame.K_DOWN] or keys[pygame.K_s]:
      self.y += self.velocity

    self.rect = (self.x,self.y,self.width,self.height)

  def pickUpItem(self, item):
    self.inventory.append(item)
    print(f"{self.name} picked up {item.name}")


  def viewInventory(self):
    if self.inventory:
      print(f"{self.name}'s Inventory")
      for item in self.inventory:
        print(item.name) #only prints the name

    else:
      print(f"{self.name}'s inventory is empty")


class Card(Player):
  def __init__(self, cardName):
    self.name = cardName
    self.x = 60
    self.y = 60
    self.width = 50
    self.height = 70
    self.colour = (139, 0, 0)
    self.rect = (self.x, self.y, self.width, self.height)
    

  def draw(self, WIN):
    pygame.draw.rect(WIN, self.colour, self.rect)
    
    


#MainBackground = pygame.image.load("Fountain image.png")

def redrawWindow(WIN, player):
  MainBackground = pygame.image.load("Fountain image.png")
  MainBackground = pygame.transform.scale(MainBackground, (width, height))
  WIN.blit(MainBackground, (0, 0))
  player.draw(WIN)
  pygame.display.update()

class Network:
    def __init__(self):
        self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server = "192.168.0.50"
        self.port = 5555
        self.addr = (self.server, self.port)
        self.id = self.connect()
        print(self.id)


    def connect(self):
        try:
            self.client.connect(self.addr)
            return self.client.recv(2048).decode()
        except:
            pass
    def send(self, data):
        try:
            self.client.send(str.encode(data))
            return self.client.recv(2048).decode()
        except socket.error as e:
            print(e)

n = Network()
print(n.send("Hello"))
print(n.send("Working"))

HOST = "192.168.0.50"
PORT = 55555

clients = [] #to hold which clients are connected

def threaded_client(conn): #runs in background
    conn.send(str.encode("Connected"))
    
    while True:
        try:
            #this receives the data from the client
            data = conn.recv(2048) #larger the size, longer it takes to recieve 

            if not data:
                print("Disconnected")
                break
            
            for client in clients:
                if client != conn:
                    try:
                        client.send(data)
                    except:
                        clients.remove(client)
        except:
            break
    
    clients.remove(conn)
    print("Lost connection")
    conn.close()


def server():
    socketForServer = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    socketForServer.bind((HOST, PORT))
    socketForServer.listen()

    while True: #continuously listens for connections
        conn, addr = socketForServer.accept(conn, addr) #accepts incoming connections
        clients.append(conn)
        print("Connected to:", addr)

        #need to start a new thread for each client that's connected
        clientHandler = threading.Thread(target=threaded_client, args=(conn,))
        clientHandler.start()


if __name__ == "__main__":
    server()

class Client:
    def __init__(self):
        self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.host = "192.168.0.50"
        self.port = 55555
        self.address = (self.host, self.port)
        self.player = None

    def connect(self):
        self.client_socket.connect(self.address)
        #this receives inital data from the server when it connects
        print(self.clien_socket.recv(2048).decode())

    def sendPosition(self):
        if self.player:
            self.player.send_position(self.client_socket)
        
    def receivePositions(self):
        if self.player:
            return self.player.receive_position(self.client_socket)
    
    def close(self):
        self.client_socket.close()

class Murderer:
    def __init__(self, characterList, roomList, weaponList):
        self.characterlist = characterList
        self.roomList = roomList
        self.weaponList = weaponList

    def chooseMurdererName(self):
        self.murdererName = random.choice(self.characterlist)
        
    
    def chooseMurderRoom(self):
        self.murderRoom = random.choice(self.roomList)
    
    def chooseMurderWeapon(self):
        self.murderWeapon = random.choice(self.weaponList)
    
    def revealMurderer(self):
        print(f"It was {self.murdererName} in the {self.murderRoom} with the {self.murderWeapon}")

characterList = ["Mrs White", "Miss Scarlet", "Miss Peacock", "Professor Plum", "Colnel Mustard", "Reverand Green"]
roomList = ["Garage", "Dining Room", "Bathroom", "Conservatory", "Bedroom", "Study", "Fountain", "Living Room"]
weaponList = ["Lead Pipe", "Rope", "Candlestick", "Revolver", "Spanner", "Dagger"]

def main():
  client = Client()
  client.connect()
  p = Player(50, 50, 50, 50, random.choice(listOfColours), "Player 1")
  cardsNotFound = []
  cardObjects = []
  cardsForRoom = []
  murder = Murderer(characterList, roomList, weaponList)
  murder.chooseMurdererName()
  murder.chooseMurderRoom()
  murder.chooseMurderWeapon()
  cardsNotFound.remove(murder.self.murdererName)
  cardsNotFound.remove(murder.self.murderRoom)
  cardsNotFound.remove(murder.self.murderWeapon)
  with open("CardList.txt") as file:
    cardsNotFound = [line.rstrip() for line in file]
    for line in file:
      card_name = line.strip()
      card_object = Card(card_name)
      cardObjects.append(card_object)

  for i in range(3):
    randomX = random.randint(0, width - 50) #makes sure the card is actually in the window
    randomY = random.randint(0, height - 70)
    card_object = Card(f"Card {i + 1}")
    card_object.x = randomX
    card_object.y = randomY
    cardsForRoom.append(card_object)
    
  run = True
  while run:
    for event in pygame.event.get():
      if event.type == pygame.QUIT:
        run = False
        pygame.quit()
    p.move()
    client.sendPosition()
    otherPlayersPositions = client.receivePositions()
    for playerPosition in otherPlayersPositions:
      p.updatePosition(playerPosition)
    #if p.self.x < 0 or p.self.x > width - p.self.rect or p.self.y < 0 or p.self.y > height - p.self.rect:
      #WIN.
      #need to find background x and y values and speed and then use background x - background speed to update it as the player hits the edge of the screen
      #pass
    Fountain = Card("Fountain")
    Fountain.draw(WIN)
    redrawWindow(WIN, p)
    player_rect = Rect(p.rect)
    Fountain_rect = Rect(Fountain.rect)
    if player_rect.colliderect(Fountain_rect):
      p.inventory.append(Fountain)
      #cardsNotFound.remove(Fountain.name)
    for card_object in cardsForRoom:
      card_object.draw(WIN)
      

    pygame.display.update()
    pygame.time.Clock().tick(450)
    client.close()
main()


pygame.quit()
sys.exit()
